node("docker-ubuntu20-xlarge") {
    properties([
        pipelineTriggers([
            cron('H 0 * * *')
        ])
    ])
    try {
        statusMatrix = [:]
        stage('Setup Environment and Tools') {
            def goRoot = tool name: 'go-1.23.9', type: 'go'
            withEnv(["GOROOT=${goRoot}", "PATH+GO=${goRoot}/bin"]) {
                withCredentials([string(credentialsId: 'repo21-url', variable: 'REPO21_URL')]) {
                    echo "${REPO21_URL}"
                    def repo21Name = "${REPO21_URL}".substring(8, "${REPO21_URL}".length())
                    env.REPO_NAME_21 = "$repo21Name"
                }
                def reposMap = [
                   /* "artifactory-jenkins-plugin": [url: "https://github.com/jfrog/jenkins-artifactory-plugin", branch:"master", type: "maven", jdk:"8"],
                    "build-info-extractor": [url: "https://github.com/jfrog/build-info", branch: "master", type: "gradle", buildDir:"build/libs", jdk:"8"],
                    "teamcity-artifactory-plugin": [url: "https://github.com/jfrog/teamcity-artifactory-plugin.git", branch: "master",  type: "maven", jdk:"8"],
                    "artifactory-maven-plugin": [url: "https://github.com/jfrog/artifactory-maven-plugin.git", branch: "master", type: "maven", jdk:"8"],
                    "artifactory-client-java": [url: "https://github.com/jfrog/artifactory-client-java.git", branch: "master", type: "gradle", buildDir:"services/build/libs", "jdk":"8"],
                    "artifactory-gradle-plugin": [url: "https://github.com/jfrog/artifactory-gradle-plugin.git", branch: "main", type: "gradle", buildDir:"build/libs", jdk:"8"],
                    "file-specs-java": [url: "https://github.com/jfrog/file-specs-java.git", branch: "main", type: "gradle", buildDir:"build/libs", jdk:"8"],*/
                    "jfrog-testing-infra": [url: "https://github.com/jfrog/jfrog-testing-infra.git", branch: "main", dir:"java", type: "gradle", buildDir:"build/libs", jdk:"8"]
                    /*"bamboo-artifactory-plugin": [url: "https://github.com/jfrog/bamboo-artifactory-plugin.git", branch: "master", type: "maven", jdk:"11"],
                    "jfrog-plugin": [url: "https://github.com/jenkinsci/jfrog-plugin.git", branch:"main", type: "maven", j∂çdk:"11"],
                    "bamboo-jfrog-plugin": [url: "https://github.com/jfrog/bamboo-jfrog-plugin.git", branch: "main", type: "maven", jdk:"11"],
                    "jfrog-azure-devops-extension": [url: "https://github.com/jfrog/jfrog-azure-devops-extension.git",branch: "dev", type: "npm"],
                    "cocoapods-art": [url: "https://github.com/jfrog/cocoapods-art.git", branch: "master", type: "ruby"],
                    "jfrog-setup-cli": [url: "https://bitbucket.org/jfrog/jfrog-setup-cli.git", branch: "master", type: "docker"]*/
                ]

                buildStatus = 'SUCCESS'
                cliExecutableName = 'jf'
                repo = 'jfrog-cli'
                formattedDate = new Date().format('yyyy-MM-dd')
                env.CI = true
                env.JFROG_CLI_LOG_LEVEL = "DEBUG"
                dir('temp') {
                    sh "cat /etc/lsb-release"
                    cliWorkspace = pwd()
                    sh "echo cliWorkspace=$cliWorkspace"
                    builderDir = "${cliExecutableName}-builder/"
                    sh "mkdir $builderDir"
                    builderPath = "/usr/local/bin/jf"
                    jfrogCliRepoDir = "${cliWorkspace}/${repo}/"
                    zippedBinariesDir = "${jfrogCliRepoDir}zippedBinaries/"
                    pluginName = params.PLUGINS_NAME
                    formattedDate = new Date().format('yyyy-MM-dd')
                    slackChannelName = "ecosytem-plugins-dev-build-notifications"
                    watchName = "ecosystem-watch"
                    pluginSelectedForOnDemandScanning=""
                    stage('Installing Jf'){
                        try  {
                        script{
                             installJfrogCli()
                            }
                        }
                        catch (e) {
                            notifyFailure('Installing Jf', e)
                            throw e
                        }
                    }
                    stage('Select Plugins for execution'){
                        try  {
                        script{
                             selectPlugins(reposMap)
                            }
                        }
                        catch (e) {
                            notifyFailure('Select Plugins for execution', e)
                            throw e
                        }
                    }
                    stage('Installing Tools'){
                        script {
                            sh "mkdir -p ${zippedBinariesDir}"
                            sh 'apt-get update -y && apt-get install -y unzip'

                            def mvnHome = installMaven("3.9.6")

                            def gradleHomePath = installGradle('8.5')

                            configRepo21()

                            def jdk8Path = installJdkFromArchive('8')

                            installNodeJs()

                            def tasks = [:]
                            reposMap.each { repoName, details ->
                                tasks[repoName] = {
                                    statusMatrix[repoName] = [Build: 'PENDING', Upload: 'PENDING', Scan: 'PENDING']
                                    buildBinary(repoName, details, mvnHome, jdk8Path, gradleHomePath)
                                }
                            }
                            parallel(tasks)
                            cleanupRepo21()
                        }
                    }
                }
            }
        }
    } catch (e) {
        echo "ERROR: Pipeline failed with exception: ${e}"
        buildStatus = 'FAILURE'
        throw e
    }
    finally {
        stage('Send Notifications') {
            def message = ''
            def summary = formatStatusMatrix(statusMatrix)
            if (buildStatus == 'SUCCESS') {
                message = "Dev Build Jenkins Pipeline has successfully completed.\n<${env.BUILD_URL}|View Build>${summary}"
                slackSend(channel: "#${slackChannelName}", message: message, color: 'good')
            } else {
                message = """@here Dev Build Jenkins Pipeline has a problem.
                *Status* : *${buildStatus}*.
                *Build* : <${env.BUILD_URL}|${env.JOB_NAME} #${env.BUILD_NUMBER}>${summary}"""
                slackSend(channel: "#${slackChannelName}", message: message, color: 'danger')
            }
            echo "Final notification message would be: \n${message}"
        }
    }
}

def formatStatusMatrix(Map matrix) {
    def message = "\n"
    matrix.each { repo, stages ->
        message += "• *${repo}*: "
        message += "Build: ${stages.Build}, "
        message += "Upload: ${stages.Upload}, "
        message += "Scan: ${stages.Scan}\n"
    }
    return message
}

def notifyFailure(String stageName, error) {
    def message = """@here :x: *Build FAILED!*
    *Job:* `${env.JOB_NAME}` #${env.BUILD_NUMBER}
    *Failed Stage:* `${stageName}`
    *Error:* `${error.message.trim()}`
    *<${env.BUILD_URL}|Open Build Log>*"""
    echo "Sending failure notification for stage: ${stageName}"
    slackSend(
        channel: "#${slackChannelName}",
        color: 'danger',
        message: message
    )
}

def installJdkFromArchive(String version) {
    def jdkUrlMap = [
        "8": "https://api.adoptium.net/v3/binary/latest/8/ga/linux/x64/jdk/hotspot/normal/eclipse",
        "11": "https://api.adoptium.net/v3/binary/latest/11/ga/linux/x64/jdk/hotspot/normal/eclipse"
    ]
    def downloadUrl = jdkUrlMap[version]
    if (!downloadUrl) {
        error "No download URL defined for JDK version ${version}"
    }

    sh "curl -L -o jdk.tar.gz '${downloadUrl}'"
    sh "tar -xzf jdk.tar.gz"

    def jdkDirName = sh(script: "find . -maxdepth 1 -type d -name '*jdk*'", returnStdout: true).trim()

    if (jdkDirName.isEmpty()) {
        error "Could not find extracted JDK directory."
    }

    return "${pwd()}/${jdkDirName}"
}

def installGradle(String version) {
    echo "--- Installing Gradle v${version} ---"

    def downloadUrl = "https://services.gradle.org/distributions/gradle-${version}-bin.zip"
    sh "curl --fail -L -o gradle.zip '${downloadUrl}'"

    sh "unzip gradle.zip"

    def gradleDirName = sh(script: "find . -maxdepth 1 -type d -name 'gradle-*'", returnStdout: true).trim()
    if (gradleDirName.isEmpty()) {
        error "Could not find extracted Gradle directory."
    }

    def gradleHome = "${pwd()}/${gradleDirName}"
    return gradleHome
}

def installMaven(String mavenVersion){
    sh "curl -O https://archive.apache.org/dist/maven/maven-3/${mavenVersion}/binaries/apache-maven-${mavenVersion}-bin.tar.gz"
    sh "tar -xzf apache-maven-${mavenVersion}-bin.tar.gz"
    def mvnHome = "${pwd()}/apache-maven-${mavenVersion}"
    return mvnHome
}

def cloneAndBuild(repoName, details, mvnHome, gradleHomePath) {
    withEnv(["PATH+MAVEN=${mvnHome}/bin",
            "PATH+GRADLE=${gradleHomePath}/bin"]) {
        echo "--- Starting process for ${repoName} ---"
        sh "java -version"
        sh "mvn -v"
        sh 'gradle -v'
        dir(repoName) {
            switch (details.type) {
                case "maven":
                    executeMaven(repoName, details)
                case "gradle":
                    executeGradle(repoName, details)
                default:
                    echo "--- Unsupported project type  ---"
            }
        }
    }
}

def executeMaven(repoName, details){
    echo "Cloning from ${details.url}..."
    git url: details.url, branch: details.branch

    try{
        sh 'mvn clean install -DskipTests'
        statusMatrix[repoName]["Build"] = '✅ SUCCESS'
    }catch (e) {
        statusMatrix[repoName]["Build"] = '❌ FAILURE'
    }

    def jarFiles = findFiles(glob: 'target/**/*.jar')
    if (jarFiles.size() > 0) {
        def zipFileName = "${repoName}-binaries.zip"
        zip(zipFile: zipFileName, dir: 'target', glob: '**/*.jar')
        echo "Successfully created ${zipFileName}"
        UploadAndScanBinary(repoName, "${zipFileName}", "**/*.zip")
    }
    def zipFiles = findFiles(glob: 'target/*.zip')
    if (zipFiles.size() > 0) {
        UploadAndScanBinary(repoName, "target/*.zip", "**/*.zip")
    }
}

def UploadAndScanBinary(repoName, uploadFileName, scanFileName){
    stage("Upload Binary for ${repoName}"){
        try{
            sh "${builderPath} rt u '${uploadFileName}' 'ecosys-dev-build-artifactory/plugins/dev/${formattedDate}/' --flat"
            statusMatrix[repoName]["Upload"] = '✅ SUCCESS'
        }catch (e) {
            statusMatrix[repoName]["Upload"] = '❌ FAILURE'
        }
    }
    stage("Scan Binary for ${repoName}"){
        try{
            sh "${builderPath} gradlec --server-id-resolve=repo21 --repo-resolve=ecosys-dev-build-artifactory"
            sh "cp .jfrog/projects/gradle.yaml .jfrog/gradle.yaml"
            sh "${builderPath} scan --server-id=repo21 '${scanFileName}' --ant=true --watches ${watchName} --format=simple-json > scan-results.json"
            def results = readJSON(file: 'scan-results.json')
            if (results.errors) {
                echo "jf scan reported the following errors:"
                results.errors.each { err ->
                    echo "- ${err.errorMessage}"
                }
            }
            statusMatrix[repoName]["Scan"] = '✅ SUCCESS'
        }catch(e){
            echo "Inside Scan Binary Catch"
            statusMatrix[repoName]["Scan"] = '❌ FAILURE'
        }
        finally {
            echo "Cleaning up scan results file..."
            sh "rm -f scan-results.json"
        }
    }
}

def installJfrogCli() {
    sh 'curl -fL https://install-cli.jfrog.io | sh'
    sh '/usr/local/bin/jf --version'
}

def executeGradle(repoName, details){
    echo "Cloning from ${details.url}...Inside executeGradle"
    git url: details.url, branch: details.branch

    def buildLogic={
        echo "Contents Inside.."
        sh "pwd"
        sh "ls -la"
        echo "Starting Gradle build for ${repoName}..."

        def hasFunctionalTest = sh(script: "./gradlew tasks --all | grep 'functionalTest' || true", returnStdout: true).trim()
        if (hasFunctionalTest) {
            echo "Project has a 'functionalTest' task. Excluding it."
            try{
                sh './gradlew clean build -x test -x functionalTest'
                statusMatrix[repoName]["Build"] = '✅ SUCCESS'
            }catch (e) {
                statusMatrix[repoName]["Build"] = '❌ FAILURE'
            }
        } else {
            echo "Project does not have a 'functionalTest' task."
            try{
                sh './gradlew clean build -x test'
                statusMatrix[repoName]["Build"] = '✅ SUCCESS'
            }catch (e) {
                statusMatrix[repoName]["Build"] = '❌ FAILURE'
            }
        }

        def buildOutputDir = details.buildDir
        sh "ls -la ${buildOutputDir}"

        def jarFiles = findFiles(glob: "${buildOutputDir}/*.jar")
        if (jarFiles.size() > 0) {
            def zipFileName = "${repoName}-binaries.zip"
            zip(zipFile: zipFileName, dir: buildOutputDir, glob: '**/*.jar')
            echo "Successfully created ${zipFileName}"
            UploadAndScanBinary(repoName, "${zipFileName}", "${zipFileName}")
        }

        def zipFiles = findFiles(glob: "${buildOutputDir}/*.zip")
        if (zipFiles.size() > 0) {
            UploadAndScanBinary(repoName, "${buildOutputDir}/*.zip", "${buildOutputDir}/*.zip")
        }
    }
    if(details.dir){
        dir(details.dir){
            buildLogic()
        }
    }else{
        buildLogic()
    }
}

def executeJDKProject(repoName, details, mvnHome, jdk8Path, gradleHomePath){
    if(details.jdk=="8"){
        withEnv(["JAVA_HOME=${jdk8Path}", "PATH+JAVA=${jdk8Path}/bin"]) {
            cloneAndBuild(repoName, details, mvnHome, gradleHomePath)
        }
    } else if(details.jdk=="11"){
        cloneAndBuild(repoName, details, mvnHome, gradleHomePath)
    }
}

def installNodeJs() {
    sh 'apt-get update -y'
    sh 'apt-get install -y nodejs npm'

    sh 'node -v'
    sh 'npm -v'
}

def buildBinary(repoName, details, mvnHome, jdk8Path, gradleHomePath){
    stage("Build Binary for ${repoName}"){
        switch (details.type) {
            case ["maven", "gradle"]:
                executeJDKProject(repoName, details, mvnHome, jdk8Path, gradleHomePath)
                break
            case "ruby":
                buildAndProcessRubyGem(repoName, details)
                break
            case "npm":
                executeNPMProject(repoName, details)
                break
            case "docker":
                buildAndScanPipeImage(repoName, details)
                break
            default:
                echo "--- Unsupported project type  ---"
                break
        }
    }
}

def executeNPMProject(repoName, details){
    dir(repoName){
        git url: details.url, branch: details.branch
        sh 'npm install'

        sh 'npm run create'

        def vsixFile = sh(script: "find . -name '*.vsix'", returnStdout: true).trim()
        if (vsixFile.isEmpty()) {
            error "Build failed: Could not find generated .vsix file."
        }

        def zipFileName = "${vsixFile}.zip"
        zip(zipFile: zipFileName, archive: false, glob: vsixFile)
        echo "Successfully created zip archive: ${zipFileName}"
        UploadAndScanBinary(repoName, "${zipFileName}", "${zipFileName}")
    }
}

def buildAndProcessRubyGem(repoName, details){
    dir(repoName){
        git url: details.url, branch: details.branch
        //sh "${builderPath} audit --watches ${watchName} --format=simple-json"
    }
}

def buildAndScanPipeImage(repoName, details) {
    dir(repoName) {
        git url: details.url, branch: details.branch
        String imageName = "jfrog-setup-cli-pipe:${formattedDate}"
        def dockerImage = docker.build(imageName)

        String tarFileName = "jfrog-setup-cli-pipe_${formattedDate}.tar"
        String zipFileName = "jfrog-setup-cli-pipe_${formattedDate}.zip"

        sh "docker save -o ${tarFileName} ${imageName}"

        zip(zipFile: zipFileName, archive: false, glob: tarFileName)
        UploadAndScanBinary(repoName, "${zipFileName}", "${zipFileName}")
    }
}

def selectPlugins(Map reposMap) {
    def buildCauses = currentBuild.getBuildCauses()

    def timerCause = buildCauses.find { it instanceof hudson.triggers.TimerTrigger$TimerTriggerCause }
    if (!timerCause) {
        pluginSelectedForOnDemandScanning=pluginName
    } else {
        pluginSelectedForOnDemandScanning="all"
    }
}

def configRepo21() {
    withCredentials([
        // jfrog-ignore
        usernamePassword(credentialsId: 'repo21', usernameVariable: 'REPO21_USER', passwordVariable: 'REPO21_PASSWORD'),
        string(credentialsId: 'repo21-url', variable: 'REPO21_URL')
    ]) {
        sh "${builderPath} c add repo21 --url=${REPO21_URL} --user=${REPO21_USER} --password=${REPO21_PASSWORD} --overwrite"
        sh "${builderPath} c use repo21"
    }
}

def cleanupRepo21() {
    sh "${builderPath} c rm repo21 --quiet"
}