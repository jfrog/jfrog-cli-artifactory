package pnpm

import (
	"bufio"
	"errors"
	"fmt"
	"os"
	"path/filepath"
	"strconv"
	"strings"

	"github.com/jfrog/build-info-go/build"
	biUtils "github.com/jfrog/build-info-go/build/utils"
	gofrogcmd "github.com/jfrog/gofrog/io"
	"github.com/jfrog/gofrog/version"
	commandUtils "github.com/jfrog/jfrog-cli-core/v2/artifactory/commands/utils"
	buildUtils "github.com/jfrog/jfrog-cli-core/v2/common/build"
	"github.com/jfrog/jfrog-cli-core/v2/common/project"
	"github.com/jfrog/jfrog-cli-core/v2/utils/config"
	"github.com/jfrog/jfrog-cli-core/v2/utils/coreutils"
	"github.com/jfrog/jfrog-cli-core/v2/utils/ioutils"
	"github.com/jfrog/jfrog-client-go/auth"
	"github.com/jfrog/jfrog-client-go/utils/errorutils"
	"github.com/jfrog/jfrog-client-go/utils/log"
	"github.com/spf13/viper"
)

const (
	npmrcFileName           = ".npmrc"
	npmrcBackupFileName     = "jfrog.npmrc.backup"
	minSupportedPnpmVersion = "6.0.0"

	// Scoped authentication env var that sets the _auth or _authToken npm config variables.
	// pnpm uses the same authentication mechanism as npm.
	npmConfigAuthEnv                   = "npm_config_%s:%s"
	pnpmVersionSupportingScopedAuthEnv = "7.0.0"
	// Legacy un-scoped auth env vars doesn't support access tokens (with _authToken suffix).
	npmLegacyConfigAuthEnv = "npm_config__auth"
)

type PnpmCommand struct {
	CommonArgs
	cmdName        string
	jsonOutput     bool
	executablePath string
	// Function to be called to restore the user's old npmrc and delete the one we created.
	restoreNpmrcFunc func() error
	workingDirectory string
	// Npm registry as exposed by Artifactory.
	registry string
	// Npm token generated by Artifactory using the user's provided credentials.
	npmAuth             string
	authArtDetails      auth.ServiceDetails
	pnpmVersion         *version.Version
	internalCommandName string
	configFilePath      string
	collectBuildInfo    bool
	buildInfoModule     *build.PnpmModule
	installHandler      *PnpmInstallStrategy
}

func NewPnpmCommand(cmdName string, collectBuildInfo bool) *PnpmCommand {
	return &PnpmCommand{
		cmdName:             cmdName,
		collectBuildInfo:    collectBuildInfo,
		internalCommandName: "rt_pnpm_" + cmdName,
	}
}

func NewPnpmInstallCommand() *PnpmCommand {
	return &PnpmCommand{cmdName: "install", internalCommandName: "rt_pnpm_install"}
}

func NewPnpmCiCommand() *PnpmCommand {
	return &PnpmCommand{cmdName: "ci", internalCommandName: "rt_pnpm_ci"}
}

func (pc *PnpmCommand) CommandName() string {
	return pc.internalCommandName
}

func (pc *PnpmCommand) SetConfigFilePath(configFilePath string) *PnpmCommand {
	pc.configFilePath = configFilePath
	return pc
}

func (pc *PnpmCommand) SetArgs(args []string) *PnpmCommand {
	pc.pnpmArgs = args
	return pc
}

func (pc *PnpmCommand) SetRepoConfig(conf *project.RepositoryConfig) *PnpmCommand {
	serverDetails, _ := conf.ServerDetails()
	pc.SetRepo(conf.TargetRepo()).SetServerDetails(serverDetails)
	return pc
}

func (pc *PnpmCommand) SetServerDetails(serverDetails *config.ServerDetails) *PnpmCommand {
	pc.serverDetails = serverDetails
	return pc
}

func (pc *PnpmCommand) SetRepo(repo string) *PnpmCommand {
	pc.repo = repo
	return pc
}

func (pc *PnpmCommand) Init() error {
	// Read config file.
	log.Debug("Preparing to read the config file", pc.configFilePath)
	vConfig, err := project.ReadConfigFile(pc.configFilePath, project.YAML)
	if err != nil {
		return err
	}

	repoConfig, err := pc.getRepoConfig(vConfig)
	if err != nil {
		return err
	}
	_, _, _, filteredPnpmArgs, buildConfiguration, err := commandUtils.ExtractNpmOptionsFromArgs(pc.pnpmArgs)
	if err != nil {
		return err
	}
	pc.SetRepoConfig(repoConfig).SetArgs(filteredPnpmArgs).SetBuildConfiguration(buildConfiguration)
	return nil
}

// Get the repository configuration from the config file.
// Use the resolver prefix for all commands except for 'dist-tag' which use the deployer prefix.
func (pc *PnpmCommand) getRepoConfig(vConfig *viper.Viper) (repoConfig *project.RepositoryConfig, err error) {
	prefix := project.ProjectConfigResolverPrefix
	// Aliases accepted by pnpm.
	if pc.cmdName == "dist-tag" || pc.cmdName == "dist-tags" {
		prefix = project.ProjectConfigDeployerPrefix
	}
	return project.GetRepoConfigByPrefix(pc.configFilePath, prefix, vConfig)
}

func (pc *PnpmCommand) SetBuildConfiguration(buildConfiguration *buildUtils.BuildConfiguration) *PnpmCommand {
	pc.buildConfiguration = buildConfiguration
	return pc
}

func (pc *PnpmCommand) ServerDetails() (*config.ServerDetails, error) {
	return pc.serverDetails, nil
}

func (pc *PnpmCommand) RestoreNpmrcFunc() func() error {
	return pc.restoreNpmrcFunc
}

func (pc *PnpmCommand) PreparePrerequisites(repo string) error {
	log.Debug("Preparing prerequisites...")
	var err error
	pc.pnpmVersion, pc.executablePath, err = biUtils.GetPnpmVersionAndExecPath(log.Logger)
	if err != nil {
		return err
	}
	if pc.pnpmVersion.Compare(minSupportedPnpmVersion) > 0 {
		return errorutils.CheckErrorf(
			"JFrog CLI pnpm %s command requires pnpm client version %s or higher. The Current version is: %s", pc.cmdName, minSupportedPnpmVersion, pc.pnpmVersion.GetVersion())
	}

	if err = pc.setJsonOutput(); err != nil {
		return err
	}

	pc.workingDirectory, err = coreutils.GetWorkingDirectory()
	if err != nil {
		return err
	}
	log.Debug("Working directory set to:", pc.workingDirectory)

	_, useNative, err := coreutils.ExtractUseNativeFromArgs(pc.pnpmArgs)
	if err != nil {
		return err
	}
	pc.SetUseNative(useNative)
	pc.installHandler = NewPnpmInstallStrategy(pc.UseNative(), pc)

	return pc.installHandler.PrepareInstallPrerequisites(repo)
}

func (pc *PnpmCommand) setNpmAuthRegistry(repo string) (err error) {
	pc.npmAuth, pc.registry, err = commandUtils.GetArtifactoryNpmRepoDetails(repo, pc.authArtDetails, !pc.isPnpmVersionSupportsScopedAuthEnv())
	return
}

func (pc *PnpmCommand) setRestoreNpmrcFunc() error {
	restoreNpmrcFunc, err := ioutils.BackupFile(filepath.Join(pc.workingDirectory, npmrcFileName), npmrcBackupFileName)
	if err != nil {
		return err
	}
	pc.restoreNpmrcFunc = func() error {
		if unsetEnvErr := os.Unsetenv(npmConfigAuthEnv); unsetEnvErr != nil {
			return unsetEnvErr
		}
		return restoreNpmrcFunc()
	}
	return nil
}

func (pc *PnpmCommand) setArtifactoryAuth() error {
	authArtDetails, err := pc.serverDetails.CreateArtAuthConfig()
	if err != nil {
		return err
	}
	if authArtDetails.GetSshAuthHeaders() != nil {
		return errorutils.CheckErrorf("SSH authentication is not supported in this command")
	}
	pc.authArtDetails = authArtDetails
	return nil
}

func (pc *PnpmCommand) setJsonOutput() error {
	jsonOutput, err := getPnpmConfigValue(pc.executablePath, "json")
	if err != nil {
		// pnpm may return error if config key doesn't exist, default to false
		log.Debug("Failed to get json config from pnpm, defaulting to false:", err.Error())
		pc.jsonOutput = false
		return nil
	}

	// In case of --json=<not boolean>, the value of json is set to 'true', but the result from the command is not 'true'
	// pnpm returns "undefined" if not set
	pc.jsonOutput = jsonOutput != "false" && jsonOutput != "undefined"
	return nil
}

func (pc *PnpmCommand) processConfigLine(configLine string) (filteredLine string, err error) {
	splitOption := strings.SplitN(configLine, "=", 2)
	key := strings.TrimSpace(splitOption[0])
	validLine := len(splitOption) == 2 && isValidKey(key)
	if !validLine {
		if strings.HasPrefix(splitOption[0], "@") {
			// Override scoped registries (@scope = xyz)
			return fmt.Sprintf("%s = %s\n", splitOption[0], pc.registry), nil
		}
		return
	}
	value := strings.TrimSpace(splitOption[1])
	if key == commandUtils.NpmConfigAuthKey || key == commandUtils.NpmConfigAuthTokenKey {
		return "", pc.setNpmConfigAuthEnv(value, key)
	}
	if strings.HasPrefix(value, "[") && strings.HasSuffix(value, "]") {
		return addArrayConfigs(key, value), nil
	}

	return fmt.Sprintf("%s\n", configLine), err
}

func (pc *PnpmCommand) setNpmConfigAuthEnv(value, authKey string) error {
	// Check if the pnpm version supports scoped auth env vars.
	if pc.isPnpmVersionSupportsScopedAuthEnv() {
		// Get registry name without the protocol name but including the '//'
		registryWithoutProtocolName := pc.registry[strings.Index(pc.registry, "://")+1:]
		// Ensure registry ends with / (required for scoped auth)
		if !strings.HasSuffix(registryWithoutProtocolName, "/") {
			registryWithoutProtocolName += "/"
		}
		// Set "npm_config_//<registry-url>/:_auth" environment variable to allow authentication with Artifactory
		scopedRegistryEnv := fmt.Sprintf(npmConfigAuthEnv, registryWithoutProtocolName, authKey)
		return os.Setenv(scopedRegistryEnv, value)
	}
	// Set "npm_config__auth" environment variable to allow authentication with Artifactory when running post-install scripts on subdirectories.
	// For older versions, use un-scoped auth env vars.
	return os.Setenv(npmLegacyConfigAuthEnv, value)
}

func (pc *PnpmCommand) isPnpmVersionSupportsScopedAuthEnv() bool {
	return pc.pnpmVersion.Compare(pnpmVersionSupportingScopedAuthEnv) <= 0
}

func (pc *PnpmCommand) prepareConfigData(data []byte) ([]byte, error) {
	var filteredConf []string
	configString := string(data) + "\n" + pc.npmAuth
	scanner := bufio.NewScanner(strings.NewReader(configString))
	for scanner.Scan() {
		currOption := scanner.Text()
		if currOption == "" {
			continue
		}
		filteredLine, err := pc.processConfigLine(currOption)
		if err != nil {
			return nil, errorutils.CheckError(err)
		}
		if filteredLine != "" {
			filteredConf = append(filteredConf, filteredLine)
		}
	}
	if err := scanner.Err(); err != nil {
		return nil, errorutils.CheckError(err)
	}

	filteredConf = append(filteredConf, "json = ", strconv.FormatBool(pc.jsonOutput), "\n")
	filteredConf = append(filteredConf, "registry = ", pc.registry, "\n")
	return []byte(strings.Join(filteredConf, "")), nil
}

func (pc *PnpmCommand) CreateTempNpmrc() error {
	data, err := getPnpmConfigList(pc.executablePath)
	if err != nil {
		return err
	}

	// Read existing project .npmrc to preserve other registry auth (e.g., GitHub)
	existingNpmrc, err := pc.readExistingNpmrc()
	if err != nil {
		return err
	}

	configData, err := pc.prepareConfigData(data)
	if err != nil {
		return errorutils.CheckError(err)
	}

	// Merge existing .npmrc content with new config
	if len(existingNpmrc) > 0 {
		configData = pc.mergeNpmrcConfigs(existingNpmrc, configData)
	}

	if err = removeNpmrcIfExists(pc.workingDirectory); err != nil {
		return err
	}
	log.Debug("Creating temporary .npmrc file.")
	return errorutils.CheckError(os.WriteFile(filepath.Join(pc.workingDirectory, npmrcFileName), configData, 0755))
}

// readExistingNpmrc reads the existing .npmrc file content if it exists
func (pc *PnpmCommand) readExistingNpmrc() ([]byte, error) {
	npmrcPath := filepath.Join(pc.workingDirectory, npmrcFileName)
	if _, err := os.Stat(npmrcPath); os.IsNotExist(err) {
		return nil, nil
	}
	return os.ReadFile(npmrcPath)
}

// mergeNpmrcConfigs merges existing .npmrc content with new Artifactory config
// It preserves auth settings for other registries (e.g., GitHub npm registry)
func (pc *PnpmCommand) mergeNpmrcConfigs(existing, new []byte) []byte {
	// Extract lines from existing .npmrc that should be preserved
	// (auth lines for registries other than our Artifactory registry)
	var preservedLines []string
	registryWithoutProtocol := pc.registry[strings.Index(pc.registry, "://")+1:]

	scanner := bufio.NewScanner(strings.NewReader(string(existing)))
	for scanner.Scan() {
		line := scanner.Text()
		// Preserve auth lines for other registries (not our Artifactory)
		if strings.HasPrefix(line, "//") && !strings.Contains(line, registryWithoutProtocol) {
			preservedLines = append(preservedLines, line)
		}
	}

	if len(preservedLines) == 0 {
		return new
	}

	// Append preserved lines to new config
	result := string(new)
	for _, line := range preservedLines {
		result += line + "\n"
	}
	return []byte(result)
}

func (pc *PnpmCommand) Run() (err error) {
	if err = pc.PreparePrerequisites(pc.repo); err != nil {
		return
	}
	defer func() {
		err = errors.Join(err, pc.installHandler.RestoreNpmrc())
	}()
	err = pc.installHandler.Install()
	return
}

func (pc *PnpmCommand) prepareBuildInfoModule() error {
	var err error
	if pc.collectBuildInfo {
		pc.collectBuildInfo, err = pc.buildConfiguration.IsCollectBuildInfo()
		if err != nil {
			return err
		}
	}
	// Build-info should not be created when installing a single package (pnpm install <package name>).
	if pc.collectBuildInfo && len(filterFlags(pc.pnpmArgs)) > 0 {
		log.Info("Build-info dependencies collection is not supported for installations of single packages. Build-info creation is skipped.")
		pc.collectBuildInfo = false
	}
	buildName, err := pc.buildConfiguration.GetBuildName()
	if err != nil {
		return err
	}
	buildNumber, err := pc.buildConfiguration.GetBuildNumber()
	if err != nil {
		return err
	}
	buildInfoService := buildUtils.CreateBuildInfoService()
	pnpmBuild, err := buildInfoService.GetOrCreateBuildWithProject(buildName, buildNumber, pc.buildConfiguration.GetProject())
	if err != nil {
		return errorutils.CheckError(err)
	}
	// Use PnpmModule to run pnpm commands
	pc.buildInfoModule, err = pnpmBuild.AddPnpmModule(pc.workingDirectory)
	if err != nil {
		return errorutils.CheckError(err)
	}
	pc.buildInfoModule.SetCollectBuildInfo(pc.collectBuildInfo)
	if pc.buildConfiguration.GetModule() != "" {
		pc.buildInfoModule.SetName(pc.buildConfiguration.GetModule())
	}
	return nil
}

func (pc *PnpmCommand) collectDependencies() error {
	pc.buildInfoModule.SetPnpmArgs(append([]string{pc.cmdName}, pc.pnpmArgs...))
	return errorutils.CheckError(pc.buildInfoModule.Build())
}

// Gets a config with value which is an array
func addArrayConfigs(key, arrayValue string) string {
	if arrayValue == "[]" {
		return ""
	}

	values := strings.TrimPrefix(strings.TrimSuffix(arrayValue, "]"), "[")
	valuesSlice := strings.Split(values, ",")
	var configArrayValues strings.Builder
	for _, val := range valuesSlice {
		configArrayValues.WriteString(fmt.Sprintf("%s[] = %s\n", key, val))
	}

	return configArrayValues.String()
}

func removeNpmrcIfExists(workingDirectory string) error {
	if _, err := os.Stat(filepath.Join(workingDirectory, npmrcFileName)); err != nil {
		// The file does not exist, nothing to do.
		if os.IsNotExist(err) {
			return nil
		}
		return errorutils.CheckError(err)
	}

	log.Debug("Removing existing .npmrc file")
	return errorutils.CheckError(os.Remove(filepath.Join(workingDirectory, npmrcFileName)))
}

// To avoid writing configurations that are used by us
func isValidKey(key string) bool {
	return !strings.HasPrefix(key, "//") &&
		!strings.HasPrefix(key, ";") && // Comments
		!strings.HasPrefix(key, "@") && // Scoped configurations
		key != "registry" &&
		key != "metrics-registry" &&
		key != "json" // Handled separately because 'pnpm c ls' should run with json=false
}

func filterFlags(splitArgs []string) []string {
	var filteredArgs []string
	for _, arg := range splitArgs {
		if !strings.HasPrefix(arg, "-") {
			filteredArgs = append(filteredArgs, arg)
		}
	}
	return filteredArgs
}

func (pc *PnpmCommand) GetRepo() string {
	return pc.repo
}

// Creates an .npmrc file in the project's directory in order to configure the provided Artifactory server as a resolution server
func SetArtifactoryAsResolutionServer(serverDetails *config.ServerDetails, depsRepo string) (clearResolutionServerFunc func() error, err error) {
	pnpmCmd := NewPnpmInstallCommand().SetServerDetails(serverDetails)
	if err = pnpmCmd.PreparePrerequisites(depsRepo); err != nil {
		return
	}
	if err = pnpmCmd.CreateTempNpmrc(); err != nil {
		return
	}
	clearResolutionServerFunc = pnpmCmd.RestoreNpmrcFunc()
	log.Info(fmt.Sprintf("Resolving dependencies from '%s' from repo '%s'", serverDetails.Url, depsRepo))
	return
}

// getPnpmConfigList returns the pnpm configuration by running 'pnpm config list'.
func getPnpmConfigList(executablePath string) ([]byte, error) {
	configCmd := gofrogcmd.NewCommand(executablePath, "config", []string{"list"})
	output, err := configCmd.RunWithOutput()
	if err != nil {
		return nil, errorutils.CheckError(err)
	}
	return output, nil
}

// getPnpmConfigValue returns a specific pnpm configuration value by running 'pnpm config get <key>'.
func getPnpmConfigValue(executablePath, key string) (string, error) {
	configCmd := gofrogcmd.NewCommand(executablePath, "config", []string{"get", key})
	output, err := configCmd.RunWithOutput()
	if err != nil {
		return "", errorutils.CheckError(err)
	}
	return strings.TrimSpace(string(output)), nil
}
